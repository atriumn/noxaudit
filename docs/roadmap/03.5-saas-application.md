# Phase 3.5: SaaS Application

## Why this is a separate doc

Phase 3 covers the **marketing site and docs** — what a visitor sees before they sign up. Phase 4 covers the **business model** — pricing, billing, what's gated. This doc covers what sits between them: the **actual product** that users log into, the screens they see, the data that flows through the system, and the technical architecture that holds it together.

This is the application. Without this doc, someone building Phase 4 would know *what* to charge for but not *what to build*.

## What success looks like

A developer signs up with GitHub OAuth, connects a repo, and within 5 minutes sees their first audit results in a dashboard that's faster and more useful than reading markdown files. A team lead adds their team, sees health across all their repos, and triages findings without touching the CLI. The application feels fast, purposeful, and worth paying for.

Specifically:

- Time from signup to first meaningful dashboard view: under 5 minutes
- Page loads under 200ms for all primary views
- A user who's only ever used the CLI can navigate the app without documentation
- The app adds value the CLI can't: visual trends, team coordination, cross-repo comparison
- Mobile-usable for checking status and triaging, but desktop-optimized for deep work

## User roles and journeys

### Individual developer (Pro tier)

**First session**:
1. Lands on noxaudit.com, clicks "Sign in with GitHub"
2. Authorizes the GitHub App (read access to repos, write for PR comments/issues)
3. Sees an empty dashboard with "Connect your first repo"
4. Selects a repo from their GitHub repos list
5. Chooses: run first audit now, or wait for next scheduled run
6. If "run now": sees a progress indicator, then findings populate in ~2-5 minutes
7. Explores findings, clicks into a specific one, sees the code context and suggestion
8. Makes their first decision (accept/dismiss/intentional) from the UI

**Daily use**:
- Opens dashboard, sees overnight audit summary
- Scans new findings (sorted by severity, filtered by focus area)
- Triages: dismisses false positives, accepts real issues, kicks auto-fix on fixable ones
- Checks the "auto-fix" tab to see pending PRs, merges the clean ones
- Glances at the trend chart — are things getting better or worse?

### Team lead (Team tier)

**First session**:
1. Signs up, creates an organization
2. Invites team members (via GitHub team or email)
3. Connects multiple repos, assigns ownership
4. Configures org-wide schedule and notification preferences
5. Sees the org overview with all repos at a glance

**Weekly use**:
- Monday morning: open org dashboard, check weekend audit results
- Identify repos that need attention (health score dropped)
- Assign findings to specific team members
- Review team resolution metrics — who's triaging, what's stuck
- Check cost dashboard — are we within budget?
- Generate a weekly summary to share in standup

### Triager (any tier)

**Core loop**:
1. Open findings inbox (filtered to assigned or unassigned)
2. For each finding:
   - Read the title and severity
   - Click to expand: see full description, affected file, code context, suggestion
   - Decide: dismiss (with reason), accept (creates issue/ticket), or trigger auto-fix
3. Bulk actions for obvious categories (dismiss all "unused import" findings)
4. Check resolution queue: findings that were accepted — are they fixed yet?

## Application structure

### Information architecture

```
App
├── Dashboard (home)
│   ├── [Pro] Single repo overview
│   └── [Team] Org overview → drill into repos
│
├── Repos
│   ├── Repo list (connect, disconnect, configure)
│   └── Repo detail
│       ├── Findings (filterable, sortable, actionable)
│       ├── Audit history (timeline of all runs)
│       ├── Auto-fix activity (PRs opened, merged, failed)
│       ├── Trends (charts over time)
│       └── Settings (schedule, focus areas, notifications)
│
├── Findings
│   ├── Inbox view (all findings across repos, triage-focused)
│   ├── Finding detail (code context, suggestion, decision history)
│   └── Bulk actions (multi-select, batch dismiss/assign)
│
├── Auto-fix
│   ├── Pending fixes (PRs awaiting review)
│   ├── Fix history (merged, rejected, failed)
│   └── Fix settings (confidence thresholds, auto-merge rules)
│
├── Trends & Analytics [Team+]
│   ├── Org-wide health over time
│   ├── Per-repo health comparison
│   ├── Focus area breakdown
│   ├── Resolution metrics (MTTR, resolution rate)
│   └── Cost analytics
│
├── Team [Team+]
│   ├── Members (invite, roles, permissions)
│   ├── Activity feed (who did what)
│   └── Assignments (who owns which findings)
│
└── Settings
    ├── Account (profile, GitHub connection)
    ├── Organization [Team+]
    ├── Billing (plan, usage, invoices)
    ├── API keys
    ├── Notifications (channels, preferences)
    └── Integrations (Slack, Jira, Linear)
```

### Key screens (detailed)

#### 1. Dashboard / Home

**Pro (single repo)**:

```
┌─────────────────────────────────────────────────────────────┐
│  my-app                                          Health: 82 │
│  Last audit: 2h ago (security)  Next: tonight (patterns)    │
│                                                             │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │
│  │ 3 new    │ │ 2 fixes  │ │ 12 open  │ │ 47 total │      │
│  │ findings │ │ pending  │ │ findings │ │ resolved │      │
│  └──────────┘ └──────────┘ └──────────┘ └──────────┘      │
│                                                             │
│  [Trend chart: findings over last 30 days, by severity]     │
│                                                             │
│  New findings                                               │
│  ● critical  SQL injection in user_auth.py:47      [Triage] │
│  ● medium    Stale docstring in api/views.py:102   [Triage] │
│  ● low       Unused import in utils/helpers.py:3   [Triage] │
│                                                             │
│  Auto-fix PRs                                               │
│  ✓ #142 Remove dead code (3 files)              [Merged 1h] │
│  ○ #143 Update stale docstrings (2 files)        [Open, CI] │
└─────────────────────────────────────────────────────────────┘
```

**Team (org overview)**:

```
┌─────────────────────────────────────────────────────────────┐
│  Acme Corp                                   Org Health: 76 │
│  12 repos · 4 members · Last audit: 1h ago                  │
│                                                             │
│  [Heat map: repos by health score]                          │
│   api-gateway ████████░░ 84   web-app    ██████░░░░ 62     │
│   auth-svc    █████████░ 91   payments   ████░░░░░░ 43     │
│   ...                                                       │
│                                                             │
│  Needs attention                                            │
│  ▼ payments (health: 43, -12 this week)                     │
│    5 critical findings, 0 triaged                           │
│  ▼ web-app (health: 62, -4 this week)                       │
│    2 critical findings, 1 auto-fix failed                   │
│                                                             │
│  This week                                                  │
│  14 audits · 23 findings · 8 auto-fixed · 6 triaged        │
└─────────────────────────────────────────────────────────────┘
```

#### 2. Finding detail

```
┌─────────────────────────────────────────────────────────────┐
│  ← Back to findings                                         │
│                                                             │
│  ● CRITICAL  SQL injection vulnerability                    │
│  security · my-app · Found 2h ago                           │
│                                                             │
│  File: src/api/user_auth.py:47                    [GitHub ↗]│
│  ┌─────────────────────────────────────────────────────┐    │
│  │  45 │ def get_user(request):                        │    │
│  │  46 │     user_id = request.GET.get('id')           │    │
│  │  47 │     cursor.execute(f"SELECT * FROM users      │ ◄  │
│  │     │         WHERE id = {user_id}")                │    │
│  │  48 │     return cursor.fetchone()                  │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  Description                                                │
│  User input is interpolated directly into a SQL query       │
│  without parameterization. An attacker can inject arbitrary │
│  SQL via the `id` query parameter.                          │
│                                                             │
│  Suggested fix                                              │
│  Use parameterized queries:                                 │
│  cursor.execute("SELECT * FROM users WHERE id = %s",       │
│                  (user_id,))                                │
│                                                             │
│  ┌──────────┐ ┌──────────┐ ┌───────────┐ ┌──────────────┐ │
│  │ Auto-fix │ │ Dismiss  │ │ Accepted  │ │ Intentional  │ │
│  └──────────┘ └──────────┘ └───────────┘ └──────────────┘ │
│                                                             │
│  Decision history                                           │
│  (none — this is a new finding)                             │
│                                                             │
│  Related findings                                           │
│  Similar pattern in src/api/admin.py:83 (medium)            │
└─────────────────────────────────────────────────────────────┘
```

#### 3. Trends

```
┌─────────────────────────────────────────────────────────────┐
│  Trends · my-app · Last 90 days                             │
│                                                             │
│  [Line chart: total open findings over time]                │
│  ───── critical  ───── high  ───── medium  ───── low       │
│                                                             │
│  [Stacked bar: findings by focus area per week]             │
│  ▓ security  ▓ patterns  ▓ docs  ▓ testing  ▓ other       │
│                                                             │
│  Resolution metrics                                         │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────┐       │
│  │ MTTR         │ │ Auto-fix     │ │ Resolution   │       │
│  │ 2.3 days     │ │ rate: 68%    │ │ rate: 91%    │       │
│  │ ↓ from 4.1   │ │ ↑ from 52%   │ │ ↑ from 84%   │       │
│  └──────────────┘ └──────────────┘ └──────────────┘       │
│                                                             │
│  Cost                                                       │
│  This month: $47.20 · Avg per audit: $1.69                  │
│  [Bar chart: cost per audit over time]                      │
└─────────────────────────────────────────────────────────────┘
```

## Data architecture

### What the CLI sends to the backend

The CLI already produces all the data. The SaaS layer needs it centralized. When a user connects a repo, audits report results to the backend via a new `--report-to` flag (or automatic for paid users).

**Audit result payload**:

```
{
  repo: string,
  focus: string | string[],
  provider: string,
  model: string,
  timestamp: ISO 8601,
  duration_seconds: number,
  token_usage: {
    input: number,
    output: number,
    cache_read: number,
    cache_write: number
  },
  findings: Finding[],
  new_findings: Finding[],       // after decision filtering
  resolved_count: number,
  cost_estimate_usd: number
}
```

### Data store schema (core entities)

```
organizations
  id, name, created_at, plan, stripe_customer_id

users
  id, github_id, github_login, email, created_at

org_memberships
  org_id, user_id, role (viewer | triager | admin | owner)

repos
  id, org_id, github_repo_id, name, full_name, default_branch,
  schedule (jsonb), config (jsonb), health_score, last_audit_at

audits
  id, repo_id, focus, provider, model, started_at, completed_at,
  status (running | completed | failed),
  token_usage (jsonb), cost_usd, finding_count, new_finding_count

findings
  id, repo_id, audit_id, focus, severity, status (open | resolved | dismissed),
  file, line, title, description, suggestion, confidence,
  first_seen_at, resolved_at, assigned_to (user_id)

decisions
  id, finding_id, user_id, action (accept | dismiss | intentional),
  reason, created_at, file_hash

fixes
  id, finding_id, repo_id, status (pending | applied | merged | failed),
  pr_url, pr_number, diff, confidence, test_passed,
  created_at, merged_at

daily_snapshots (pre-computed for trends)
  repo_id, date, focus,
  open_critical, open_high, open_medium, open_low,
  resolved_count, new_count, health_score
```

### Data flows

```
CLI audit run
  │
  ├── [Free users] Results stay local (markdown, JSON)
  │
  └── [Paid users] POST /api/audits → Backend
        │
        ├── Store audit + findings in Postgres
        ├── Compute health score delta
        ├── Update daily_snapshots
        ├── Trigger notifications (Slack, email)
        ├── If auto-fix enabled: queue fix generation jobs
        └── Update dashboard (WebSocket push or poll)

Dashboard request
  │
  ├── Auth check (session cookie → user → org → repos)
  ├── Query Postgres (findings, audits, snapshots)
  ├── Return JSON to frontend
  └── Frontend renders (React, server components where possible)

Auto-fix flow
  │
  ├── Fix job picked up from queue
  ├── Clone repo (or use GitHub API for file content)
  ├── Generate fix via LLM (standard API, not batch)
  ├── Create branch + commit via GitHub API
  ├── Open PR via GitHub API
  ├── Store fix record in Postgres
  └── Notify user (dashboard + Slack/email)
```

## Technical architecture

### Stack

| Layer | Technology | Rationale |
|---|---|---|
| **Frontend** | Next.js (App Router) + React | Same framework as marketing site (Phase 3); server components for fast initial loads; huge ecosystem |
| **Styling** | Tailwind CSS | Utility-first, consistent with developer tool aesthetic, fast iteration |
| **Charts** | Recharts or Tremor | Tremor is built for dashboards on Tailwind; Recharts if more customization needed |
| **Backend API** | Next.js API routes (initially) → separate service if needed | Start simple; split when API complexity or scaling demands it |
| **Database** | PostgreSQL (via Neon or Supabase) | Relational data, complex queries (findings by repo by date by severity), proven at scale |
| **ORM** | Drizzle or Prisma | Drizzle for lighter weight and SQL-close syntax; Prisma if team prefers it |
| **Auth** | NextAuth.js with GitHub provider (→ WorkOS for enterprise SSO in Phase 5) | Free, well-integrated with Next.js, handles GitHub OAuth cleanly |
| **Job queue** | Inngest or BullMQ | Inngest for serverless-native (Vercel); BullMQ if running own infra (Railway/Fly) |
| **File storage** | Cloudflare R2 or S3 | Reports, SARIF files, diffs — write once, read many |
| **Hosting** | Vercel (frontend) + Railway or Fly.io (workers) | Vercel for Next.js is zero-config; workers need long-running processes (fix generation) that Vercel can't handle |
| **Billing** | Stripe (Checkout + Billing Portal + Metered Billing) | Standard; handles subscriptions, metered usage, invoices, tax |
| **Real-time** | Vercel KV (Redis) + Server-Sent Events | Lightweight; for audit progress indicators and dashboard live updates |
| **Monitoring** | Sentry (errors) + Plausible (analytics) | Developer-standard; Plausible is privacy-respecting |

### Deployment topology

```
                    ┌─────────────────┐
                    │   Vercel Edge    │
                    │  (Next.js app)   │
                    │  Marketing site  │
                    │  Dashboard       │
                    │  API routes      │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
    ┌─────────▼──┐  ┌───────▼────┐  ┌─────▼───────┐
    │  Neon /     │  │ Cloudflare │  │  Inngest /  │
    │  Supabase   │  │  R2        │  │  BullMQ     │
    │  (Postgres) │  │  (files)   │  │  (jobs)     │
    └────────────┘  └────────────┘  └──────┬──────┘
                                           │
                                    ┌──────▼──────┐
                                    │  Railway /   │
                                    │  Fly.io      │
                                    │  (workers)   │
                                    │  Fix gen,    │
                                    │  audit runs  │
                                    └─────────────┘
```

### CLI ↔ Backend integration

The CLI needs to talk to the backend without breaking the OSS experience. This must be opt-in and seamless.

**Authentication**: `noxaudit login` opens a browser for GitHub OAuth, stores a token locally in `~/.noxaudit/credentials`. Subsequent CLI commands include the token in API calls.

**Result reporting**: When logged in, `noxaudit run` automatically posts results to the backend after the audit completes. The CLI workflow is unchanged — results still write to local files. The backend is an additional destination, not a replacement.

**Offline-first**: If the backend is unreachable, the CLI works normally. Results queue locally and sync on next successful connection. Paid features (managed scheduling, team triage) gracefully degrade to CLI equivalents.

## Notification system

### Channels and behavior

| Channel | Pro | Team | Enterprise | Payload |
|---|---|---|---|---|
| **Email** | Digest (daily/weekly) | Per-audit or digest | Configurable | Summary + top findings + trend |
| **Slack** | Single channel | Per-team channels | + DMs for assignments | Block Kit: summary, severity badges, action buttons |
| **Dashboard** | In-app badge + feed | + team activity feed | + org-wide feed | Real-time via SSE |
| **Webhook** | — | Generic webhook | + custom headers/auth | Full JSON payload, HMAC signed |

### Notification triggers

| Event | Default behavior |
|---|---|
| Audit completed | Dashboard update; email/Slack if new critical/high findings |
| New critical finding | Immediate Slack + email (not just digest) |
| Auto-fix PR opened | Dashboard + Slack |
| Auto-fix PR merged | Dashboard |
| Auto-fix PR failed tests | Dashboard + Slack (needs attention) |
| Finding assigned to you | Dashboard + email |
| Health score dropped >10 pts | Slack alert to team channel |
| Policy violation (Phase 5) | Immediate to configured channel |

Users configure preferences per channel. Defaults should be opinionated but not noisy — a new user should get useful notifications without configuring anything, and should never feel spammed.

## Design principles for the app

**Information density over whitespace.** This is a tool for developers, not a consumer app. Show more data per screen. Tables are fine. Dense is fine. Wasted space is not.

**Keyboard-navigable.** Power users will want `j/k` to move between findings, `d` to dismiss, `a` to accept, `f` to trigger auto-fix. Vim-style keybindings as a progressive enhancement.

**Dark mode default.** Developers use dark mode. Light mode should exist but dark is the primary design target.

**No loading spinners on primary views.** Pre-compute aggregations (daily snapshots), use server components for initial data, stream updates. The dashboard should feel like a local app, not a web page waiting for an API.

**Progressive disclosure.** The finding list shows title + severity + file. Click to expand: full description, code context, suggestion. Click again: decision history, related findings, audit metadata. Each level of detail is opt-in.

**Actionable defaults.** Every view should have a clear "what do I do next?" — the findings inbox sorts by severity and highlights untriaged items. The dashboard shows "needs attention" before "all good." The auto-fix tab surfaces failed fixes before successful ones.

## Dependencies & sequencing

```
GitHub OAuth + user accounts ──────── (foundation, start first)
  │
  ├── CLI login + result reporting ──── (needs auth)
  │
  ├── Repo connection flow ──────────── (needs auth + GitHub App)
  │
  └── Database schema + API ─────────── (needs auth, informed by schema above)
        │
        ├── Dashboard: Home ─────────── (needs API + findings data)
        │
        ├── Dashboard: Findings ─────── (needs API + findings data)
        │     └── Finding detail ────── (needs findings)
        │     └── Bulk actions ──────── (needs findings)
        │
        ├── Dashboard: Trends ───────── (needs daily_snapshots populated)
        │
        ├── Dashboard: Auto-fix ─────── (needs fix engine from Phase 2)
        │
        ├── Notification system ─────── (needs events from API)
        │     ├── Email
        │     ├── Slack
        │     └── Webhooks
        │
        ├── Team features ───────────── (needs org model)
        │     ├── Member management
        │     ├── Finding assignment
        │     └── Team activity feed
        │
        └── Billing integration ─────── (needs Stripe + plan gating)
              └── Settings + billing UI
```

Auth and the database schema are the critical path. The dashboard views can be built incrementally — start with Home and Findings (the most-used views), add Trends and Auto-fix once data accumulates.

## Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Dashboard doesn't add enough value over CLI | Users don't convert to paid | Validate with 10 CLI power users before building: "would you pay for this screen?" Focus on things the CLI genuinely can't do (trends, team coordination, cross-repo) |
| Performance degrades with scale (thousands of findings) | Dashboard feels sluggish, users churn | Pre-compute aggregations from day one; paginate findings; use database indexes aggressively; load test early |
| CLI-to-backend sync is unreliable | Missing audit data, incomplete trends | Queue-based with retry; local fallback; reconciliation endpoint that backfills gaps |
| GitHub App permissions alarm users | Drop-off during onboarding | Minimal permissions (read code, write PRs/issues); explain each permission in the connection flow; support read-only mode with manual result upload |
| Building too much app before validating demand | Wasted effort | Ship the smallest useful dashboard first (findings list + basic trends for one repo), get 20 paying users, then expand |

## How we'll know it's working

- **Activation**: >70% of users who sign up complete repo connection and see their first findings
- **Engagement**: Paying users open the dashboard >3x/week on average
- **Triage velocity**: Mean time from finding-created to decision-made decreases vs. CLI-only users
- **Auto-fix engagement**: >50% of auto-fix PRs are reviewed within 24 hours
- **Performance**: p95 page load <500ms for all primary views
- **Retention signal**: Users who see trends data (requires 2+ weeks of history) retain at 2x the rate of users who don't
